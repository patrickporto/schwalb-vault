import{f as Lt,a as it}from"../chunks/BRTMgXkI.js";import"../chunks/Dk46Yrm8.js";import{o as mn}from"../chunks/9XWO1C58.js";import{q as gn,x as ft,g as V,y as hn,v as ve,ae as re,s as Le,m as je,an as lt,af as Q}from"../chunks/BwAmkLWk.js";import{s as $e}from"../chunks/CP1S4VyT.js";import{e as wn,b as bn,i as vn}from"../chunks/D4EOzbzc.js";import{a as ut,r as xn}from"../chunks/B_OzcHYs.js";import{f as dt}from"../chunks/BYC1B8Vp.js";import{i as kn}from"../chunks/DjppR_Fy.js";import{s as An,a as Sn}from"../chunks/B2fbu9af.js";import{$ as Tn}from"../chunks/zj8xCFw8.js";const $t={p:0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2fn,n:0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141n,h:1n,a:0n,b:7n,Gx:0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798n,Gy:0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8n},{p:ce,n:Ce,Gx:Pn,Gy:En,b:Bt}=$t,Z=32,Te=64,Fe={publicKey:Z+1,publicKeyUncompressed:Te+1,seed:Z+Z/2},_n=(...e)=>{"captureStackTrace"in Error&&typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(...e)},_=(e="")=>{const t=new Error(e);throw _n(t,_),t},Cn=e=>typeof e=="bigint",Ln=e=>typeof e=="string",$n=e=>e instanceof Uint8Array||ArrayBuffer.isView(e)&&e.constructor.name==="Uint8Array",j=(e,t,n="")=>{const o=$n(e),s=e?.length,r=t!==void 0;if(!o||r&&s!==t){const l=n&&`"${n}" `,m=r?` of length ${t}`:"",u=o?`length=${s}`:`type=${typeof e}`;_(l+"expected Uint8Array"+m+", got "+u)}return e},Pe=e=>new Uint8Array(e),Mt=(e,t)=>e.toString(16).padStart(t,"0"),Ut=e=>Array.from(j(e)).map(t=>Mt(t,2)).join(""),ee={_0:48,_9:57,A:65,F:70,a:97,f:102},yt=e=>{if(e>=ee._0&&e<=ee._9)return e-ee._0;if(e>=ee.A&&e<=ee.F)return e-(ee.A-10);if(e>=ee.a&&e<=ee.f)return e-(ee.a-10)},Ot=e=>{const t="hex invalid";if(!Ln(e))return _(t);const n=e.length,o=n/2;if(n%2)return _(t);const s=Pe(o);for(let r=0,l=0;r<o;r++,l+=2){const m=yt(e.charCodeAt(l)),u=yt(e.charCodeAt(l+1));if(m===void 0||u===void 0)return _(t);s[r]=m*16+u}return s},Rt=()=>globalThis?.crypto,pt=()=>Rt()?.subtle??_("crypto.subtle must be defined, consider polyfill"),we=(...e)=>{const t=Pe(e.reduce((o,s)=>o+j(s).length,0));let n=0;return e.forEach(o=>{t.set(o,n),n+=o.length}),t},nt=(e=Z)=>Rt().getRandomValues(Pe(e)),Ze=BigInt,ue=(e,t,n,o="bad number: out of range")=>Cn(e)&&t<=e&&e<n?e:_(o),f=(e,t=ce)=>{const n=e%t;return n>=0n?n:t+n},Ie=e=>f(e,Ce),Bn=(e,t)=>{(e===0n||t<=0n)&&_("no inverse n="+e+" mod="+t);let n=f(e,t),o=t,s=0n,r=1n;for(;n!==0n;){const l=o/n,m=o%n,u=s-r*l;o=n,n=m,s=r,r=u}return o===1n?f(s,t):_("no inverse")},Mn=e=>{const t=Kt[e];return typeof t!="function"&&_("hashes."+e+" not set"),t},Je=e=>e instanceof K?e:_("Point expected"),Dt=e=>f(f(e*e)*e+Bt),mt=e=>ue(e,0n,ce),Re=e=>ue(e,1n,ce),Un=e=>ue(e,1n,Ce),be=e=>(e&1n)===0n,Nt=e=>Uint8Array.of(e),On=e=>Nt(be(e)?2:3),Ht=e=>{const t=Dt(Re(e));let n=1n;for(let o=t,s=(ce+1n)/4n;s>0n;s>>=1n)s&1n&&(n=n*o%ce),o=o*o%ce;return f(n*n)===t?n:_("sqrt invalid")};class K{static BASE;static ZERO;X;Y;Z;constructor(t,n,o){this.X=mt(t),this.Y=Re(n),this.Z=mt(o),Object.freeze(this)}static CURVE(){return $t}static fromAffine(t){const{x:n,y:o}=t;return n===0n&&o===0n?fe:new K(n,o,1n)}static fromBytes(t){j(t);const{publicKey:n,publicKeyUncompressed:o}=Fe;let s;const r=t.length,l=t[0],m=t.subarray(1),u=Xe(m,0,Z);if(r===n&&(l===2||l===3)){let g=Ht(u);const d=be(g);be(Ze(l))!==d&&(g=f(-g)),s=new K(u,g,1n)}return r===o&&l===4&&(s=new K(u,Xe(m,Z,Te),1n)),s?s.assertValidity():_("bad point: not on curve")}static fromHex(t){return K.fromBytes(Ot(t))}get x(){return this.toAffine().x}get y(){return this.toAffine().y}equals(t){const{X:n,Y:o,Z:s}=this,{X:r,Y:l,Z:m}=Je(t),u=f(n*m),g=f(r*s),d=f(o*m),a=f(l*s);return u===g&&d===a}is0(){return this.equals(fe)}negate(){return new K(this.X,f(-this.Y),this.Z)}double(){return this.add(this)}add(t){const{X:n,Y:o,Z:s}=this,{X:r,Y:l,Z:m}=Je(t),u=0n,g=Bt;let d=0n,a=0n,i=0n;const h=f(g*3n);let v=f(n*r),S=f(o*l),P=f(s*m),$=f(n+o),T=f(r+l);$=f($*T),T=f(v+S),$=f($-T),T=f(n+s);let L=f(r+m);return T=f(T*L),L=f(v+P),T=f(T-L),L=f(o+s),d=f(l+m),L=f(L*d),d=f(S+P),L=f(L-d),i=f(u*T),d=f(h*P),i=f(d+i),d=f(S-i),i=f(S+i),a=f(d*i),S=f(v+v),S=f(S+v),P=f(u*P),T=f(h*T),S=f(S+P),P=f(v-P),P=f(u*P),T=f(T+P),v=f(S*T),a=f(a+v),v=f(L*T),d=f($*d),d=f(d-v),v=f($*S),i=f(L*i),i=f(i+v),new K(d,a,i)}subtract(t){return this.add(Je(t).negate())}multiply(t,n=!0){if(!n&&t===0n)return fe;if(Un(t),t===1n)return this;if(this.equals(de))return Jn(t).p;let o=fe,s=de;for(let r=this;t>0n;r=r.double(),t>>=1n)t&1n?o=o.add(r):n&&(s=s.add(r));return o}multiplyUnsafe(t){return this.multiply(t,!1)}toAffine(){const{X:t,Y:n,Z:o}=this;if(this.equals(fe))return{x:0n,y:0n};if(o===1n)return{x:t,y:n};const s=Bn(o,ce);return f(o*s)!==1n&&_("inverse invalid"),{x:f(t*s),y:f(n*s)}}assertValidity(){const{x:t,y:n}=this.toAffine();return Re(t),Re(n),f(n*n)===Dt(t)?this:_("bad point: not on curve")}toBytes(t=!0){const{x:n,y:o}=this.assertValidity().toAffine(),s=J(n);return t?we(On(o),s):we(Nt(4),s,J(o))}toHex(t){return Ut(this.toBytes(t))}}const de=new K(Pn,En,1n),fe=new K(0n,1n,0n);K.BASE=de;K.ZERO=fe;const Rn=(e,t,n)=>de.multiply(t,!1).add(e.multiply(n,!1)).assertValidity(),ye=e=>Ze("0x"+(Ut(e)||"0")),Xe=(e,t,n)=>ye(e.subarray(t,n)),Dn=2n**256n,J=e=>Ot(Mt(ue(e,0n,Dn),Te)),Nn=e=>{const t=ye(j(e,Z,"secret key"));return ue(t,1n,Ce,"invalid secret key: outside of range")},gt="SHA-256",Kt={hmacSha256Async:async(e,t)=>{const n=pt(),o="HMAC",s=await n.importKey("raw",e,{name:o,hash:{name:gt}},!1,["sign"]);return Pe(await n.sign(o,s,t))},hmacSha256:void 0,sha256Async:async e=>Pe(await pt().digest(gt,e)),sha256:void 0},Hn=(e=nt(Fe.seed))=>{j(e),(e.length<Fe.seed||e.length>1024)&&_("expected 40-1024b");const t=f(ye(e),Ce-1n);return J(t+1n)},Kn=e=>t=>{const n=Hn(t);return{secretKey:n,publicKey:e(n)}},Zt=e=>Uint8Array.from("BIP0340/"+e,t=>t.charCodeAt(0)),Xt="aux",Vt="nonce",Yt="challenge",Ge=(e,...t)=>{const n=Mn("sha256"),o=n(Zt(e));return n(we(o,o,...t))},qe=async(e,...t)=>{const n=Kt.sha256Async,o=await n(Zt(e));return await n(we(o,o,...t))},st=e=>{const t=Nn(e),n=de.multiply(t),{x:o,y:s}=n.assertValidity().toAffine(),r=be(s)?t:Ie(-t),l=J(o);return{d:r,px:l}},ot=e=>Ie(ye(e)),It=(...e)=>ot(Ge(Yt,...e)),jt=async(...e)=>ot(await qe(Yt,...e)),Jt=e=>st(e).px,Zn=Kn(Jt),Ft=(e,t,n)=>{const{px:o,d:s}=st(t);return{m:j(e),px:o,d:s,a:j(n,Z)}},Gt=e=>{const t=ot(e);t===0n&&_("sign failed: k is zero");const{px:n,d:o}=st(J(t));return{rx:n,k:o}},qt=(e,t,n,o)=>we(t,J(Ie(e+n*o))),zt="invalid signature produced",Xn=(e,t,n=nt(Z))=>{const{m:o,px:s,d:r,a:l}=Ft(e,t,n),m=Ge(Xt,l),u=J(r^ye(m)),g=Ge(Vt,u,s,o),{rx:d,k:a}=Gt(g),i=It(d,s,o),h=qt(a,d,i,r);return Qt(h,o,s)||_(zt),h},Vn=async(e,t,n=nt(Z))=>{const{m:o,px:s,d:r,a:l}=Ft(e,t,n),m=await qe(Xt,l),u=J(r^ye(m)),g=await qe(Vt,u,s,o),{rx:d,k:a}=Gt(g),i=await jt(d,s,o),h=qt(a,d,i,r);return await en(h,o,s)||_(zt),h},Yn=(e,t)=>e instanceof Promise?e.then(t):t(e),Wt=(e,t,n,o)=>{const s=j(e,Te,"signature"),r=j(t,void 0,"message"),l=j(n,Z,"publicKey");try{const m=ye(l),u=Ht(m),g=be(u)?u:f(-u),d=new K(m,g,1n).assertValidity(),a=J(d.toAffine().x),i=Xe(s,0,Z);ue(i,1n,ce);const h=Xe(s,Z,Te);ue(h,1n,Ce);const v=we(J(i),a,r);return Yn(o(v),S=>{const{x:P,y:$}=Rn(d,h,Ie(-S)).toAffine();return!(!be($)||P!==i)})}catch{return!1}},Qt=(e,t,n)=>Wt(e,t,n,It),en=async(e,t,n)=>Wt(e,t,n,jt),tn={keygen:Zn,getPublicKey:Jt,sign:Xn,verify:Qt,signAsync:Vn,verifyAsync:en},Ve=8,In=256,nn=Math.ceil(In/Ve)+1,ze=2**(Ve-1),jn=()=>{const e=[];let t=de,n=t;for(let o=0;o<nn;o++){n=t,e.push(n);for(let s=1;s<ze;s++)n=n.add(t),e.push(n);t=n.double()}return e};let ht;const wt=(e,t)=>{const n=t.negate();return e?n:t},Jn=e=>{const t=ht||(ht=jn());let n=fe,o=de;const s=2**Ve,r=s,l=Ze(s-1),m=Ze(Ve);for(let u=0;u<nn;u++){let g=Number(e&l);e>>=m,g>ze&&(g-=r,e+=1n);const d=u*ze,a=d,i=d+Math.abs(g)-1,h=u%2!==0,v=g<0;g===0?o=o.add(wt(h,t[a])):n=n.add(wt(v,t[i]))}return e!==0n&&_("invalid wnaf"),{p:n,f:o}},{floor:We,random:Fn,sin:Gn}=Math,Ee="Trystero",_e=(e,t)=>Array(e).fill().map(t),bt="0123456789AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz",Qe=e=>_e(e,()=>bt[We(Fn()*bt.length)]).join(""),ae=Qe(20),le=Promise.all.bind(Promise),sn=typeof window<"u",{entries:vt,fromEntries:qn,keys:zn}=Object,te=()=>{},ne=e=>new Error(`${Ee}: ${e}`),Wn=new TextEncoder,Qn=new TextDecoder,he=e=>Wn.encode(e),De=e=>Qn.decode(e),et=e=>e.reduce((t,n)=>t+n.toString(16).padStart(2,"0"),""),Be=(...e)=>e.join("@"),es=(e,t)=>{const n=[...e],o=()=>{const r=Gn(t++)*1e4;return r-We(r)};let s=n.length;for(;s;){const r=We(o()*s--);[n[s],n[r]]=[n[r],n[s]]}return n},ts=(e,t,n,o)=>(e.relayUrls||es(t,on(e.appId))).slice(0,e.relayUrls?e.relayUrls.length:e.relayRedundancy||n),se=JSON.stringify,Ye=JSON.parse,on=(e,t=Number.MAX_SAFE_INTEGER)=>e.split("").reduce((n,o)=>n+o.charCodeAt(0),0)%t,xt=3333,Me={};let Se=null,tt=null;const ns=()=>{Se||(Se=new Promise(e=>{tt=e}).finally(()=>{tt=null,Se=null}))},ss=()=>tt?.(),os=(e,t)=>{const n={},o=()=>{const s=new WebSocket(e);s.onclose=()=>{if(Se){Se.then(o);return}Me[e]??=xt,setTimeout(o,Me[e]),Me[e]*=2},s.onmessage=r=>t(r.data),n.socket=s,n.url=s.url,n.ready=new Promise(r=>s.onopen=()=>{r(n),Me[e]=xt}),n.send=r=>{s.readyState===1&&s.send(r)}};return o(),n},rs=()=>{if(sn){const e=new AbortController;return addEventListener("online",ss,{signal:e.signal}),addEventListener("offline",ns,{signal:e.signal}),()=>e.abort()}return te},rt="AES-GCM",as={},cs=e=>btoa(String.fromCharCode.apply(null,new Uint8Array(e))),is=e=>{const t=atob(e);return new Uint8Array(t.length).map((n,o)=>t.charCodeAt(o)).buffer},rn=async(e,t)=>new Uint8Array(await crypto.subtle.digest(e,he(t))),Ue=async e=>as[e]||=Array.from(await rn("SHA-1",e)).map(t=>t.toString(36)).join(""),fs=async(e,t,n)=>crypto.subtle.importKey("raw",await crypto.subtle.digest({name:"SHA-256"},he(`${e}:${t}:${n}`)),{name:rt},!1,["encrypt","decrypt"]),an="$",cn=",",ls=async(e,t)=>{const n=crypto.getRandomValues(new Uint8Array(16));return n.join(cn)+an+cs(await crypto.subtle.encrypt({name:rt,iv:n},await e,he(t)))},us=async(e,t)=>{const[n,o]=t.split(an);return De(await crypto.subtle.decrypt({name:rt,iv:new Uint8Array(n.split(cn))},await e,is(o)))},ds=5e3,kt="icegatheringstatechange",At="offer",ys="answer",St=(e,{rtcConfig:t,rtcPolyfill:n,turnConfig:o})=>{const s=new(n||RTCPeerConnection)({iceServers:ps.concat(o||[]),...t}),r={};let l=!1,m=!1,u=null;const g=a=>{a.binaryType="arraybuffer",a.bufferedAmountLowThreshold=65535,a.onmessage=i=>r.data?.(i.data),a.onopen=()=>r.connect?.(),a.onclose=()=>r.close?.(),a.onerror=i=>r.error?.(i)},d=a=>Promise.race([new Promise(i=>{const h=()=>{a.iceGatheringState==="complete"&&(a.removeEventListener(kt,h),i())};a.addEventListener(kt,h),h()}),new Promise(i=>setTimeout(i,ds))]).then(()=>({type:a.localDescription.type,sdp:a.localDescription.sdp.replace(/a=ice-options:trickle\s\n/g,"")}));return e?(u=s.createDataChannel("data"),g(u)):s.ondatachannel=({channel:a})=>{u=a,g(a)},s.onnegotiationneeded=async()=>{try{l=!0,await s.setLocalDescription();const a=await d(s);r.signal?.(a)}catch(a){r.error?.(a)}finally{l=!1}},s.onconnectionstatechange=()=>{["disconnected","failed","closed"].includes(s.connectionState)&&r.close?.()},s.ontrack=a=>{r.track?.(a.track,a.streams[0]),r.stream?.(a.streams[0])},s.onremovestream=a=>r.stream?.(a.stream),e&&(s.canTrickleIceCandidates||s.onnegotiationneeded()),{created:Date.now(),connection:s,get channel(){return u},get isDead(){return s.connectionState==="closed"},async signal(a){if(!(u?.readyState==="open"&&!a.sdp?.includes("a=rtpmap")))try{if(a.type===At){if(l||s.signalingState!=="stable"&&!m){if(e)return;await le([s.setLocalDescription({type:"rollback"}),s.setRemoteDescription(a)])}else await s.setRemoteDescription(a);await s.setLocalDescription();const i=await d(s);return r.signal?.(i),i}else if(a.type===ys){m=!0;try{await s.setRemoteDescription(a)}finally{m=!1}}}catch(i){r.error?.(i)}},sendData:a=>u.send(a),destroy:()=>{u?.close(),s.close(),l=!1,m=!1},setHandlers:a=>Object.assign(r,a),offerPromise:e?new Promise(a=>r.signal=i=>{i.type===At&&a(i)}):Promise.resolve(),addStream:a=>a.getTracks().forEach(i=>s.addTrack(i,a)),removeStream:a=>s.getSenders().filter(i=>a.getTracks().includes(i.track)).forEach(i=>s.removeTrack(i)),addTrack:(a,i)=>s.addTrack(a,i),removeTrack:a=>{const i=s.getSenders().find(h=>h.track===a);i&&s.removeTrack(i)},replaceTrack:(a,i)=>{const h=s.getSenders().find(v=>v.track===a);if(h)return h.replaceTrack(i)}}},ps=[..._e(3,(e,t)=>`stun:stun${t||""}.l.google.com:19302`),"stun:stun.cloudflare.com:3478"].map(e=>({urls:e})),ms=Object.getPrototypeOf(Uint8Array),Ne=12,fn=0,He=fn+Ne,Ke=He+1,ke=Ke+1,Ae=ke+1,ie=16*2**10-Ae,Oe=255,Tt="bufferedamountlow",ge=e=>"@_"+e,gs=(e,t,n)=>{const o={},s={},r={},l={},m={},u={},g={},d={onPeerJoin:te,onPeerLeave:te,onPeerStream:te,onPeerTrack:te},a=(c,y)=>(c?Array.isArray(c)?c:[c]:zn(o)).flatMap(b=>{const x=o[b];return x?y(b,x):(console.warn(`${Ee}: no peer with id ${b} found`),[])}),i=c=>{o[c]&&(o[c].destroy(),delete o[c],delete l[c],delete m[c],d.onPeerLeave(c),t(c))},h=c=>{if(s[c])return r[c];if(!c)throw ne("action type argument is required");const y=he(c);if(y.byteLength>Ne)throw ne(`action type string "${c}" (${y.byteLength}b) exceeds byte limit (${Ne}). Hint: choose a shorter name.`);const b=new Uint8Array(Ne);b.set(y);let x=0;return s[c]={onComplete:te,onProgress:te,setOnComplete:A=>s[c]={...s[c],onComplete:A},setOnProgress:A=>s[c]={...s[c],onProgress:A},send:async(A,p,w,E)=>{if(w&&typeof w!="object")throw ne("action meta argument must be an object");const H=typeof A;if(H==="undefined")throw ne("action data cannot be undefined");const B=H!=="string",G=A instanceof Blob,k=G||A instanceof ArrayBuffer||A instanceof ms;if(w&&!k)throw ne("action meta argument can only be used with binary data");const R=k?new Uint8Array(G?await A.arrayBuffer():A):he(B?se(A):A),I=w?he(se(w)):null,C=Math.ceil(R.byteLength/ie)+(w?1:0)||1,M=_e(C,(U,D)=>{const q=D===C-1,z=w&&D===0,W=new Uint8Array(Ae+(z?I.byteLength:q?R.byteLength-ie*(C-(w?2:1)):ie));return W.set(b),W.set([x],He),W.set([q|z<<1|k<<2|B<<3],Ke),W.set([Math.round((D+1)/C*Oe)],ke),W.set(w?z?I:R.subarray((D-1)*ie,D*ie):R.subarray(D*ie,(D+1)*ie),Ae),W});return x=x+1&Oe,le(a(p,async(U,D)=>{const{channel:q}=D;let z=0;for(;z<C;){const W=M[z];if(q.bufferedAmount>q.bufferedAmountLowThreshold&&await new Promise(pn=>{const ct=()=>{q.removeEventListener(Tt,ct),pn()};q.addEventListener(Tt,ct)}),!o[U])break;D.sendData(W),z++,E?.(W[ke]/Oe,U,w)}}))}},r[c]||=[s[c].send,s[c].setOnComplete,s[c].setOnProgress]},v=(c,y)=>{const b=new Uint8Array(y),x=De(b.subarray(fn,He)).replaceAll("\0",""),[A]=b.subarray(He,Ke),[p]=b.subarray(Ke,ke),[w]=b.subarray(ke,Ae),E=b.subarray(Ae),H=!!(p&1),B=!!(p&2),G=!!(p&4),k=!!(p&8);if(!s[x]){console.warn(`${Ee}: received message with unregistered type (${x})`);return}l[c]||={},l[c][x]||={};const R=l[c][x][A]||={chunks:[]};if(B?R.meta=Ye(De(E)):R.chunks.push(E),s[x].onProgress(w/Oe,c,R.meta),!H)return;const I=new Uint8Array(R.chunks.reduce((C,M)=>C+M.byteLength,0));if(R.chunks.reduce((C,M)=>(I.set(M,C),C+M.byteLength),0),delete l[c][x][A],G)s[x].onComplete(I,c,R.meta);else{const C=De(I);s[x].onComplete(k?Ye(C):C,c)}},S=async()=>{await Y(""),await new Promise(c=>setTimeout(c,99)),vt(o).forEach(([c,y])=>{y.destroy(),delete o[c]}),n()},[P,$]=h(ge("ping")),[T,L]=h(ge("pong")),[F,oe]=h(ge("signal")),[pe,O]=h(ge("stream")),[X,N]=h(ge("track")),[Y,me]=h(ge("leave"));return e((c,y)=>{o[y]||(o[y]=c,c.setHandlers({data:b=>v(y,b),stream:b=>{d.onPeerStream(b,y,u[y]),delete u[y]},track:(b,x)=>{d.onPeerTrack(b,x,y,g[y]),delete g[y]},signal:b=>F(b,y),close:()=>i(y),error:b=>{console.error(b),i(y)}}),d.onPeerJoin(y))}),$((c,y)=>T("",y)),L((c,y)=>{m[y]?.(),delete m[y]}),oe((c,y)=>o[y]?.signal(c)),O((c,y)=>u[y]=c),N((c,y)=>g[y]=c),me((c,y)=>i(y)),sn&&addEventListener("beforeunload",S),{makeAction:h,leave:S,ping:async c=>{if(!c)throw ne("ping() must be called with target peer ID");const y=Date.now();return P("",c),await new Promise(b=>m[c]=b),Date.now()-y},getPeers:()=>qn(vt(o).map(([c,y])=>[c,y.connection])),addStream:(c,y,b)=>a(y,async(x,A)=>{b&&await pe(b,x),A.addStream(c)}),removeStream:(c,y)=>a(y,(b,x)=>x.removeStream(c)),addTrack:(c,y,b,x)=>a(b,async(A,p)=>{x&&await X(x,A),p.addTrack(c,y)}),removeTrack:(c,y)=>a(y,(b,x)=>x.removeTrack(c)),replaceTrack:(c,y,b,x)=>a(b,async(A,p)=>{x&&await X(x,A),p.replaceTrack(c,y)}),onPeerJoin:c=>d.onPeerJoin=c,onPeerLeave:c=>d.onPeerLeave=c,onPeerStream:c=>d.onPeerStream=c,onPeerTrack:c=>d.onPeerTrack=c}},hs=20,ws=5333,Pt=57333,bs=({init:e,subscribe:t,announce:n})=>{const o={};let s=!1,r,l,m,u;return(g,d,a)=>{const{appId:i}=g;if(o[i]?.[d])return o[i][d];const h={},v={},S=Be(Ee,i,d),P=Ue(S),$=Ue(Be(S,ae)),T=fs(g.password||"",i,d),L=p=>async w=>({type:w.type,sdp:await p(T,w.sdp)}),F=L(us),oe=L(ls),pe=()=>St(!0,g),O=(p,w,E)=>{if(v[w]){v[w]!==p&&p.destroy();return}v[w]=p,A(p,w),h[w]?.forEach((H,B)=>{B!==E&&H.destroy()}),delete h[w]},X=(p,w)=>{v[w]===p&&delete v[w]},N=(p,w)=>{if(v[p])return;const E=h[p]?.[w];E&&(delete h[p][w],E.destroy())},Y=p=>(l.push(..._e(p,pe)),le(l.splice(0,p).map(w=>w.offerPromise.then(oe).then(E=>({peer:w,offer:E}))))),me=(p,w)=>a?.({error:`incorrect password (${g.password}) when decrypting ${w}`,appId:i,peerId:p,roomId:d}),c=p=>async(w,E,H)=>{const[B,G]=await le([P,$]);if(w!==B&&w!==G)return;const{peerId:k,offer:R,answer:I,peer:C}=typeof E=="string"?Ye(E):E;if(!(k===ae||v[k])){if(k&&!R&&!I){if(h[k]?.[p])return;const[[{peer:M,offer:U}],D]=await le([Y(1),Ue(Be(S,k))]);h[k]||=[],h[k][p]=M,setTimeout(()=>N(k,p),y[p]*.9),M.setHandlers({connect:()=>O(M,k,p),close:()=>X(M,k)}),H(D,se({peerId:ae,offer:U}))}else if(R){if(h[k]?.[p]&&ae>k)return;const U=St(!1,g);U.setHandlers({connect:()=>O(U,k,p),close:()=>X(U,k)});let D;try{D=await F(R)}catch{me(k,"offer");return}if(U.isDead)return;const[q,z]=await le([Ue(Be(S,k)),U.signal(D)]);H(q,se({peerId:ae,answer:await oe(z)}))}else if(I){let M;try{M=await F(I)}catch{me(k,"answer");return}if(C)C.setHandlers({connect:()=>O(C,k,p),close:()=>X(C,k)}),C.signal(M);else{const U=h[k]?.[p];U&&!U.isDead&&U.signal(M)}}}};if(!g)throw ne("requires a config map as the first argument");if(!i&&!g.firebaseApp)throw ne("config map is missing appId field");if(!d)throw ne("roomId argument required");if(!s){const p=e(g);l=_e(hs,pe),r=Array.isArray(p)?p:[p],s=!0,m=setInterval(()=>l=l.filter(w=>{const E=Date.now()-w.created<Pt;return E||w.destroy(),E}),Pt*1.03),u=g.manualRelayReconnection?te:rs()}const y=r.map(()=>ws),b=[],x=r.map(async(p,w)=>t(await p,await P,await $,c(w),Y));le([P,$]).then(([p,w])=>{const E=async(H,B)=>{const G=await n(H,p,w);typeof G=="number"&&(y[B]=G),b[B]=setTimeout(()=>E(H,B),y[B])};x.forEach(async(H,B)=>{await H,E(await r[B],B)})});let A=te;return o[i]||={},o[i][d]=gs(p=>A=p,p=>delete v[p],()=>{delete o[i][d],b.forEach(clearTimeout),x.forEach(async p=>(await p)()),clearInterval(m),u(),s=!1})}},vs=5,ln="x",un="EVENT",{secretKey:xs,publicKey:ks}=tn.keygen(),As=et(ks),at={},xe={},Ss={},dn=()=>Math.floor(Date.now()/1e3),yn=e=>Ss[e]??=on(e,1e4)+2e4,Et=async(e,t)=>{const n={kind:yn(e),tags:[[ln,e]],created_at:dn(),content:t,pubkey:As},o=await rn("SHA-256",se([0,n.pubkey,n.created_at,n.kind,n.tags,n.content]));return se([un,{...n,id:et(o),sig:et(await tn.signAsync(o,xs))}])},_t=(e,t)=>(at[e]=t,se(["REQ",e,{kinds:[yn(t)],since:dn(),["#"+ln]:[t]}])),Ct=e=>(delete at[e],se(["CLOSE",e])),Ts=bs({init:e=>ts(e,Ps,vs).map(t=>{const n=os(t,o=>{const[s,r,l,m]=Ye(o);if(s!==un){const u=`${Ee}: relay failure from ${n.url} - `;s==="NOTICE"?console.warn(u+r):s==="OK"&&!l&&console.warn(u+m);return}xe[r]?.(at[r],l.content)});return n.ready}),subscribe:(e,t,n,o)=>{const s=Qe(64),r=Qe(64);return xe[s]=xe[r]=(l,m)=>o(l,m,async(u,g)=>e.send(await Et(u,g))),e.send(_t(s,t)),e.send(_t(r,n)),()=>{e.send(Ct(s)),e.send(Ct(r)),delete xe[s],delete xe[r]}},announce:async(e,t)=>e.send(await Et(t,se({peerId:ae})))}),Ps=["black.nostrcity.club","ftp.halifax.rwth-aachen.de/nostr","nos.lol","nostr.cool110.xyz","nostr.data.haus","nostr.sathoarder.com","nostr.vulpem.com","relay.agorist.space","relay.binaryrobot.com","relay.damus.io","relay.fountain.fm","relay.mostro.network","relay.nostraddress.com","relay.nostrdice.com","relay.nostromo.social","relay.oldenburg.cool","relay.verified-nostr.com","yabu.me/v2"].map(e=>"wss://"+e);var Es=Lt("<div><span> </span></div>"),_s=Lt('<main class="p-4 max-w-lg mx-auto"><div class="mb-4 p-2 bg-gray-100 rounded"><h1 class="font-bold text-xl">Chat Trystero (Serverless)</h1> <p class="text-sm text-gray-600"> </p> <p class="text-xs text-gray-400"> </p></div> <div class="h-64 border rounded overflow-y-auto p-2 mb-4 bg-white"></div> <div class="flex gap-2"><input class="flex-1 border p-2 rounded" placeholder="Digite algo..."/> <button class="bg-blue-600 text-white px-4 rounded"> </button></div></main>');function Ks(e,t){gn(t,!1);const n=()=>Sn(Tn,"$_",o),[o,s]=An(),r={appId:"weird-wizard-vault"};let l,m,u=je([]),g=je(""),d=je(0);mn(()=>{l=Ts(r,"sala-geral");const[O,X]=l.makeAction("message");m=O,X((N,Y)=>{Le(u,[...V(u),{sender:"Amigo",text:N,id:Y}])}),l.onPeerJoin(N=>{lt(d),console.log(`Peer ${N} entrou`)}),l.onPeerLeave(N=>{lt(d,-1),console.log(`Peer ${N} saiu`)})});function a(){V(g)&&(m(V(g)),Le(u,[...V(u),{sender:"Eu",text:V(g),id:ae}]),Le(g,""))}kn();var i=_s(),h=re(i),v=ve(re(h),2),S=re(v);Q(v);var P=ve(v,2),$=re(P);Q(P),Q(h);var T=ve(h,2);wn(T,5,()=>V(u),vn,(O,X)=>{var N=Es(),Y=re(N),me=re(Y,!0);Q(Y),Q(N),ft(()=>{ut(N,1,`mb-2 ${V(X).sender==="Eu"?"text-right":"text-left"}`),ut(Y,1,`inline-block px-3 py-1 rounded text-sm
          ${V(X).sender==="Eu"?"bg-blue-600 text-white":"bg-gray-200 text-black"}`),$e(me,V(X).text)}),it(O,N)}),Q(T);var L=ve(T,2),F=re(L);xn(F);var oe=ve(F,2),pe=re(oe,!0);Q(oe),Q(L),Q(i),ft(O=>{$e(S,`Status: ${V(d)>0?"ðŸŸ¢ Conectado":"ðŸŸ¡ Aguardando peers..."} 
      (${V(d)??""} online)`),$e($,`ID: ${ae??""}`),$e(pe,O)},[()=>n()("chat.send")]),bn(F,()=>V(g),O=>Le(g,O)),dt("keydown",F,O=>O.key==="Enter"&&a()),dt("click",oe,a),it(e,i),hn(),s()}export{Ks as component};
